{"ts":1367272992467,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * EJS\n * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar utils = require('./utils')\n  , fs = require('fs');\n\n/**\n * Library version.\n */\n\nexports.version = '0.7.1';\n\n/**\n * Filters.\n * \n * @type Object\n */\n\nvar filters = exports.filters = require('./filters');\n\n/**\n * Intermediate js cache.\n * \n * @type Object\n */\n\nvar cache = {};\n\n/**\n * Clear intermediate js cache.\n *\n * @api public\n */\n\nexports.clearCache = function(){\n  cache = {};\n};\n\n/**\n * Translate filtered code into function calls.\n *\n * @param {String} js\n * @return {String}\n * @api private\n */\n\nfunction filtered(js) {\n  return js.substr(1).split('|').reduce(function(js, filter){\n    var parts = filter.split(':')\n      , name = parts.shift()\n      , args = parts.shift() || '';\n    if (args) args = ', ' + args;\n    return 'filters.' + name + '(' + js + args + ')';\n  });\n};\n\n/**\n * Re-throw the given `err` in context to the\n * `str` of ejs, `filename`, and `lineno`.\n *\n * @param {Error} err\n * @param {String} str\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nfunction rethrow(err, str, filename, lineno){\n  var lines = str.split('\\n')\n    , start = Math.max(lineno - 3, 0)\n    , end = Math.min(lines.length, lineno + 3);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':' \n    + lineno + '\\n' \n    + context + '\\n\\n' \n    + err.message;\n  \n  throw err;\n}\n\n/**\n * Parse the given `str` of ejs, returning the function body.\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nvar parse = exports.parse = function(str, options){\n  var options = options || {}\n    , open = options.open || exports.open || '<%'\n    , close = options.close || exports.close || '%>';\n\n  var buf = [\n      \"var buf = [];\"\n    , \"\\nwith (locals) {\"\n    , \"\\n  buf.push('\"\n  ];\n  \n  var lineno = 1;\n\n  var consumeEOL = false;\n  for (var i = 0, len = str.length; i < len; ++i) {\n    if (str.slice(i, open.length + i) == open) {\n      i += open.length\n  \n      var prefix, postfix, line = '__stack.lineno=' + lineno;\n      switch (str.substr(i, 1)) {\n        case '=':\n          prefix = \"', escape((\" + line + ', ';\n          postfix = \")), '\";\n          ++i;\n          break;\n        case '-':\n          prefix = \"', (\" + line + ', ';\n          postfix = \"), '\";\n          ++i;\n          break;\n        default:\n          prefix = \"');\" + line + ';';\n          postfix = \"; buf.push('\";\n      }\n\n      var end = str.indexOf(close, i)\n        , js = str.substring(i, end)\n        , start = i\n        , n = 0;\n        \n      if ('-' == js[js.length-1]){\n        js = js.substring(0, js.length - 2);\n        consumeEOL = true;\n      }\n        \n      while (~(n = js.indexOf(\"\\n\", n))) n++, lineno++;\n      if (js.substr(0, 1) == ':') js = filtered(js);\n      buf.push(prefix, js, postfix);\n      i += end - start + close.length - 1;\n\n    } else if (str.substr(i, 1) == \"\\\\\") {\n      buf.push(\"\\\\\\\\\");\n    } else if (str.substr(i, 1) == \"'\") {\n      buf.push(\"\\\\'\");\n    } else if (str.substr(i, 1) == \"\\r\") {\n      buf.push(\" \");\n    } else if (str.substr(i, 1) == \"\\n\") {\n      if (consumeEOL) {\n        consumeEOL = false;\n      } else {\n        buf.push(\"\\\\n\");\n        lineno++;\n      }\n    } else {\n      buf.push(str.substr(i, 1));\n    }\n  }\n\n  buf.push(\"');\\n}\\nreturn buf.join('');\");\n  return buf.join('');\n};\n\n/**\n * Compile the given `str` of ejs into a `Function`.\n *\n * @param {String} str\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nvar compile = exports.compile = function(str, options){\n  options = options || {};\n  \n  var input = JSON.stringify(str)\n    , filename = options.filename\n        ? JSON.stringify(options.filename)\n        : 'undefined';\n  \n  // Adds the fancy stack trace meta info\n  str = [\n    'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',\n    rethrow.toString(),\n    'try {',\n    exports.parse(str, options),\n    '} catch (err) {',\n    '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',\n    '}'\n  ].join(\"\\n\");\n  \n  if (options.debug) console.log(str);\n  var fn = new Function('locals, filters, escape', str);\n  return function(locals){\n    return fn.call(this, locals, filters, utils.escape);\n  }\n};\n\n/**\n * Render the given `str` of ejs.\n *\n * Options:\n *\n *   - `locals`          Local variables object\n *   - `cache`           Compiled functions are cached, requires `filename`\n *   - `filename`        Used by `cache` to key caches\n *   - `scope`           Function execution context\n *   - `debug`           Output generated function body\n *   - `open`            Open tag, defaulting to \"<%\"\n *   - `close`           Closing tag, defaulting to \"%>\"\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api public\n */\n\nexports.render = function(str, options){\n  var fn\n    , options = options || {};\n\n  if (options.cache) {\n    if (options.filename) {\n      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));\n    } else {\n      throw new Error('\"cache\" option requires \"filename\".');\n    }\n  } else {\n    fn = compile(str, options);\n  }\n\n  options.__proto__ = options.locals;\n  return fn.call(options.scope, options);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  options.filename = path;\n\n  try {\n    var str = options.cache\n      ? cache[key] || (cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n\n    fn(null, exports.render(str, options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n// express support\n\nexports.__express = exports.renderFile;\n\n/**\n * Expose to require().\n */\n\nif (require.extensions) {\n  require.extensions['.ejs'] = function(module, filename) {\n    source = require('fs').readFileSync(filename, 'utf-8');\n    module._compile(compile(source, {}), filename);\n  };\n} else if (require.registerExtension) {\n  require.registerExtension('.ejs', function(src) {\n    return compile(src, {});\n  });\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":6541}]],"length":6541}
