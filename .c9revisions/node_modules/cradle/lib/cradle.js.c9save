{"ts":1366857859871,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    url = require('url'),\n    http = require('http'),\n    https = require('https'),\n    querystring = require('querystring'),\n    request = require('request');\n\nvar cradle = exports;\n\ncradle.extend   = require('./cradle/response').extend;\ncradle.Response = require('./cradle/response').Response;\ncradle.Cache    = require('./cradle/cache').Cache;\ncradle.Database = require('./cradle/database').Database;\n\ncradle.host = '127.0.0.1';\ncradle.port = 5984;\ncradle.auth = null;\ncradle.options = {\n    cache: true,\n    raw: false,\n    timeout: 0,\n    secure: false,\n    headers: {}\n};\n\ncradle.setup = function (settings) {\n    this.host = settings.host;\n    this.auth = settings.auth;\n    this.port = parseInt(settings.port, 10);\n    cradle.merge(this.options, settings);\n\n    return this;\n};\n\nvar protocolPattern = /^(https?):\\/\\//;\n\ncradle.Connection = function Connection(/* variable args */) {\n    var args = Array.prototype.slice.call(arguments),\n        options = {},\n        remote,\n        match,\n        host, \n        port, \n        auth;\n\n    args.forEach(function (a) {\n        if (typeof(a) === 'number' || (typeof(a) === 'string' && /^\\d{2,5}$/.test(a))) {\n            port = parseInt(a);\n        } else if (typeof(a) === 'object') {\n            options = a;\n            host = host || options.host;\n            port = port || options.port;\n            auth = options.auth;\n        } else {\n            host = a;\n            \n            if (match = host.match(/^(.+)\\:(\\d{2,5})$/)) {\n                host = match[1];\n                port = parseInt(match[2]);\n            }\n        }\n    });\n\n    this.host    = host || cradle.host;\n    this.port    = port || cradle.port;\n    this.auth    = auth || cradle.auth;\n    this.options = cradle.merge({}, cradle.options, options);\n\n    this.options.maxSockets = this.options.maxSockets || 20;\n    this.options.secure     = this.options.secure     || this.options.ssl;\n\n    if (protocolPattern.test(this.host)) {\n        this.protocol = this.host.match(protocolPattern)[1];\n        this.host     = this.host.replace(protocolPattern, '');\n    }\n\n    if (this.protocol === 'https') this.options.secure = true;\n\n    if (this.auth && this.auth.user) { // Deprecation warning\n        console.log('Warning: \"user\" & \"pass\" parameters ignored. Use \"username\" & \"password\"');\n    }\n    if (this.options.ssl) { // Deprecation warning\n        console.log('Warning: \"ssl\" option is deprecated. Use \"secure\" instead.');\n    }\n\n    this.transport = (this.options.secure) ? https : http;\n    this.agent = new (this.transport.Agent)({\n        host: this.host,\n        port: this.port\n    });\n    \n    this.agent.maxSockets = this.options.maxSockets;\n};\n\n//\n// Connection.rawRequest()\n//\n//      This is a base wrapper around connections to CouchDB. Given that it handles\n//      *all* requests, including those for attachments, it knows nothing about\n//      JSON serialization and does not presuppose it is sending or receiving JSON\n//      content\n//\n// OLDAPI: function (method, path, options, data, headers)\n// \ncradle.Connection.prototype.rawRequest = function (options, callback) {\n    var promise = new(events.EventEmitter), \n        self = this;\n\n    // HTTP Headers\n    options.headers = options.headers || {};\n\n    // Set HTTP Basic Auth\n    if (this.auth) {\n        options.headers['Authorization'] = \"Basic \" + new Buffer(this.auth.username + ':' + this.auth.password).toString('base64');\n    }\n\n    // Set client-wide headers\n    Object.keys(this.options.headers).forEach(function (header) {\n        options.headers[header] = self.options.headers[header];\n    });\n            \n    if (options.query && Object.keys(options.query).length) {\n        for (var k in options.query) {\n            if (typeof(options.query[k]) === 'boolean') {\n                options.query[k] = String(options.query[k]);\n            }\n        }\n        options.path += '?' + querystring.stringify(options.query);\n    }\n\n    options.headers['Connection'] = options.headers['Connection'] || 'keep-alive';\n    options.agent = this.agent;\n    options.uri = this._url(options.path);\n    delete options.path;\n\n    return request(options, callback || function () { });\n};\n\n//\n// Connection.close()\n//\n//      Close all underlying sockets associated with the agent for the connection.\n//\ncradle.Connection.prototype.close = function () {\n  this.agent.sockets.forEach(function (socket) {\n      socket.end();\n  });\n}\n\n//\n// Connection.request()\n//\n//      This is the entry point for all requests to CouchDB, at this point,\n//      the database name has been embed in the url, by one of the wrappers.\n//\ncradle.Connection.prototype.request = function (options, callback) {\n    var headers = cradle.merge({ host: this.host }, options.headers || {}),\n        self = this;\n\n    // HTTP Headers\n    options.headers = options.headers || {};\n    \n    //\n    // Handle POST/PUT data. We also convert functions to strings,\n    // so they can be used in _design documents.\n    //\n    if (options.body) {\n        options.body = JSON.stringify(options.body, function (k, val) {\n            if (typeof(val) === 'function') {\n                return val.toString();\n            } else { return val }\n        });\n        options.headers[\"Content-Length\"] = Buffer.byteLength(options.body);\n        options.headers[\"Content-Type\"]   = \"application/json\";\n    }\n\n    return this.rawRequest(options, function (err, res, body) {\n        if (err) {\n          return callback(err);\n        }\n        else if (options.method === 'HEAD') {\n          return callback(null, res.headers, res.statusCode);\n        }\n        else if (body && body.error) {\n          cradle.extend(body, { headers: res.headers });\n          body.headers.status = res.statusCode;\n          return callback(body);\n        }\n      \n        try { body = JSON.parse(body) }\n        catch (err) { }\n      \n        if (body && body.error) {\n            cradle.extend(body, { headers: res.headers });\n            body.headers.status = res.statusCode;\n            return callback(body);\n        }\n      \n        callback(null, self.options.raw ? body : new cradle.Response(body, res));\n    });\n};\n\n//\n// The database object\n//\n//      We return an object with database functions,\n//      closing around the `name` argument.\n//\ncradle.Connection.prototype.database = function (name) {\n  return new cradle.Database(name, this)\n};\n\n//\n// Wrapper functions for the server API\n//\ncradle.Connection.prototype.databases = function (callback) {\n    this.request({ path: '/_all_dbs' }, callback);\n};\ncradle.Connection.prototype.config = function (callback) {\n    this.request({ path: '/_config' }, callback);\n};\ncradle.Connection.prototype.info = function (callback) {\n    this.request({ path: '/' }, callback);\n};\ncradle.Connection.prototype.stats = function (callback) {\n    this.request({ path: '/_stats' }, callback);\n};\ncradle.Connection.prototype.activeTasks = function (callback) {\n    this.request({ path: '/_active_tasks' }, callback);\n};\ncradle.Connection.prototype.uuids = function (count, callback) {\n    if (typeof(count) === 'function') { \n        callback = count; \n        count = null;\n    }\n    \n    this.request({ \n        method: 'GET', \n        path: '/_uuids', \n        query: count ? { count: count } : {}\n    }, callback);\n};\ncradle.Connection.prototype.replicate = function (options, callback) {\n    this.request({\n        method: 'POST', \n        path: '/_replicate', \n        query: options\n    }, callback);\n};\n\ncradle.Connection.prototype._url = function (path) {\n    var url = (this.protocol || 'http') + '://' + this.host;\n\n    if (this.port !== 443 && this.port !== 80) {\n      url += ':' + this.port;\n    }\n    \n    url += path[0] === '/' ? path : ('/' + path);\n\n    return url;\n}\n\ncradle.escape = function (id) {\n    return ['_design', '_changes', '_temp_view'].indexOf(id.split('/')[0]) === -1\n        ? querystring.escape(id)\n        : id;\n};\n\ncradle.merge = function (target) {\n    var objs = Array.prototype.slice.call(arguments, 1);\n    objs.forEach(function (o) {\n        Object.keys(o).forEach(function (attr) {\n            if (! o.__lookupGetter__(attr)) {\n                target[attr] = o[attr];\n            }\n        });\n    });\n    return target;\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":8330}]],"length":8330}
